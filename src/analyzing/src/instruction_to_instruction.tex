\section{Analyzing Impact of Intructions on Instruction}
\label{sec:analysis:missing_link}
The previous section defined the interference generated by cache coherence, and
showed how the model could be used to expose it. However, knowing where and
when the interference occurs isn't something that can readily be exploited.

This section proposes instead to perform analyses that will indicate for each
program instruction which other instruction causes interference on it, and what
kind. In effect, this corresponds to finding the sets $S_A$ and $S_E$ composed
of $\langle I_o, E, I_t \rangle$ triplets, such that $I_o$ corresponds to an
instruction that causes an interference of type $E$ on the instruction $I_t$.
$S_A$ contains all triplets for which the interference occurs in all
executions, whereas $S_E$ contains the triplets for which the interference
occurs in at least one possible execution.

Combined with the results from
Section~\ref{sec:analysis:instr_characterization}, this provides a nearly
complete understanding of the effects of cache coherence interference on
instructions. The only missing information being some complex relations between
occurrences of interference.

Obtaining such results using the model features indicated in
Section~\ref{sec:analysis:exposing_interference} can be achieved by
propagating an identifier for each instruction that generates a query all the
way to the instruction that is affected by the interference of that query.

\lstset{%
   escapeinside={(*}{*)},%
   keywordstyle=\bfseries,%
   morekeywords={while,let,in,if,then,else,def,foreach},%
   numbers=none%
}

In effect, a triplet $\langle I_o, E, I_t \rangle$ is included in $S_E$ if, and
only if, given $C_o$ and $C_t$ the caches handling $I_o$ and $I_t$
respectively:
\begin{lstlisting}
E<>(
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   and (*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*)
   and (*$C_t$*).completed_requests[0].interference_origin.iline == (*$I_o$*)
   and (*$C_t$*).completed_requests[0].interference_type == (*$E$*)
)
\end{lstlisting}
with \lstinline!instruction_addr! being the line of the affected instruction,
\lstinline!interference_origin! indicating an cache (\lstinline!author!) from
which the interference comes from, as well as the line (\lstinline!iline!) of
the instruction that generated it. \lstinline!interference_type! determines
if this is a \textit{demoting} or \textit{expelling} interference. As with the
analyses of Section~\ref{sec:analysis:instr_characterization}, the relevant
information is stored in the representation of the request held in the cache
$C_t$, and every request handled by a cache is assured to be found in
its \lstinline!completed_requests[0]! after it has been fully processed.

To determine if a triplet also belongs in $S_A$ if, the following formula is
used:
\begin{lstlisting}
A[](
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   imply (
      (*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*)
      and (*$C_t$*).completed_requests[0].interference_origin.iline == (*$I_o$*)
      and (*$C_t$*).completed_requests[0].interference_type == (*$E$*)
   )
)
\end{lstlisting}

\paragraph*{Analyzing Strategy Optimization}~~\\
Testing these two formulas for every possible triplets would lead to a
combinatorial explosion. The following strategy is proposed to reduce the
search space:
\begin{enumerate}
\item
   Instructions $I_t$ not affected by interference can be removed from
   consideration. In effect, instructions $I_t$ for which the interference
   origin stayed to its default nil value are removed from the search space.
   Testing for removal can be done using:
\begin{lstlisting}
A[](
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*)) imply
   ((*$C_t$*).completed_requests[0].interference_origin.author <= 0)
)
\end{lstlisting}
   \lstinline!interference_origin.author = 0! being UPPAAL's initial value for
   that variable, and -1 the value used to represent nil.
\item
   At this point, all remaining $I_t$ instructions are sure to be part of the
   results.  For each of these $I_t$ instructions, the other components of
   their tuple(s) have to be found. The relevant $I_o$ instructions for each
   $I_t$ instruction are those for which the associated $C_o$ is author of the
   interference. Thus, for each $I_t$, only $C_o$ that are author of an
   interference that affected $I_t$ are kept. These $C_o$ verify:
\begin{lstlisting}
E<>((*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*))
\end{lstlisting}
\item
   At this point, the relevant $C_o$ caches for each $I_t$ instructions are
   known. The search for the appropriate $I_o$ instructions can be shortened by
   only considering those within a range obtained using the \lstinline!sup! and
   \lstinline!inf! operators. Indeed, the following query looks for the minimum
   line number for $I_o$ instructions that generated an interference on $I_t$:
\begin{lstlisting}
inf{
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   and ((*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*))
}: ((*$C_t$*).completed_requests[0].interference_origin.iline
\end{lstlisting}
By replacing \lstinline!inf! with \lstinline!sup!, the highest line number for
an instruction $I_o$ that generated an interference on $I_t$ can be obtained.
\item
   At this point, the relevant $I_t$ and $C_o$ associations are known, but the
   $I_o$ instructions still have a number of candidates which might not all be
   part of the result. Thus, each $I_o$ candidate has to be tested individually
   in order to ensure it verifies:
\begin{lstlisting}
E<>(
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   and (*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*)
   and (*$C_t$*).completed_requests[0].interference_origin.iline == (*$I_o$*)
)
\end{lstlisting}
\item
   At this point, the relevant $I_t$, $C_o$, and $I_o$ are associated, and all
   that remains is to determine the type of interference $E$ for each
   such association. As there are only two possible values for $E$, both should
   be tested in turn:
\begin{lstlisting}
E<>(
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   and (*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*)
   and (*$C_t$*).completed_requests[0].interference_origin.iline == (*$I_o$*)
   and (*$C_t$*).completed_requests[0].interference_type == (*$E$*)
)
\end{lstlisting}
\item
   At this point, all remaining associations form the tuples that constitute
   $S_E$. Checking if those tuples also belongs to $S_A$ is done by testing:
\begin{lstlisting}
A[](
   ((*$C_t$*).completed_requests[0].instruction_addr == (*$I_t$*))
   imply (
      (*$C_t$*).completed_requests[0].interference_origin.author == (*$C_o$*)
      and (*$C_t$*).completed_requests[0].interference_origin.iline == (*$I_o$*)
      and (*$C_t$*).completed_requests[0].interference_type == (*$E$*)
   )
)
\end{lstlisting}
\end{enumerate}

\begin{example}[Instruction Interference on the Model from Section~\ref{sec:analysis:demo_model}]
\begin{figure}[hbt!]
\centering
\input{\chapterdirectory/figure/instruction_to_instruction.tex}
\caption{Interference Between Instructions on Model from
Section~\ref{sec:analysis:demo_model}}
\label{fig:analysis:interference_between_instructions}
\end{figure}

Figure~\ref{fig:analysis:interference_between_instructions} shows the
interference between the instructions of the model from
Section~\ref{sec:analysis:demo_model}. The edges go from the instruction
generating the interference to the one being affected. \lstinline!EX! stands
for \textit{Expelling} interference and \lstinline!DE! stands for
\textit{Demoting}. The dashed lines indicate interference that
occurs only on some of the possible executions. The column on the left
corresponds to the instructions of Core1's program. The column on the right
corresponds the equivalent for Core2. The results from
Example~\ref{ex:analysis:instr_chara} have been copied to
the figure in order to ease readability.

The interference generated by cache coherence in the model from
Section~\ref{sec:analysis:demo_model} can thus be understood to be affecting
the instructions on Core1 as follows:
\begin{itemize}
\item
   The first instruction on Core1 is \textit{always-miss}, but not because of
   cache coherence. It can affect the fifth instruction on Core2 by generating
   an expelling interference on the memory element at address 1.
\item
   The second instruction on Core1 is also \textit{always-miss}, and does not
   generate or suffers interference other than minor one.
\item
   The third instruction on Core1 is \textit{uncategorized} as it can be
   affected by the first instruction on Core2 through an expelling
   interference. It is likely that this interference is linked to the one that
   can be generated by the first instruction of Core1, and that only one occurs
   in any execution.
\item
   The fourth instruction on Core1 is also \textit{uncategorized}, yet is not
   the target of any interference. This implies the accuracy of this
   instruction is determined by whether the third instruction is affected by
   interference or not. Since cache hits do not generate interference (as they
   do not generate queries), the potential expelling interference generated by
   this instruction can only occur if the third instruction was affected by
   interference. It is unclear whether the interference is generated whenever
   this fourth instruction is a miss or if it can be a miss yet not generate it.
\item
   The fifth instruction on Core1 is an \textit{always-miss} that cannot be
   caused by interference. It always causes an interference for the tenth
   instruction on Core2, as it forces the permissions acquired by Core2's
   third instruction to be restricted.
\item
   The sixth instruction on Core1 is an \textit{always-miss}, as it always
   suffers from an expelling interference caused by Core2's fourth instruction.
   This instruction can affect Core2's ones in two places, either its sixth or
   its ninth. It is unclear whether it may also not generate any interference
   in some executions.
\item
   The seventh instruction on Core1 is an \textit{always-hit}, thus neither
   suffering from, nor generating interference.
\item
   the eighth instruction on Core1 is an \textit{always-miss}, as it always
   suffers from a demoting interference from Core2's fifth instruction.
   It can cause an expelling interference on the eighth instruction of Core2.
\item
   The ninth instruction on Core1 is \textit{uncategorized}, as it may suffer
   from an \textit{expelling} interference from Core2's sixth instruction.
\item
   The tenth and final instruction on Core1 is also \textit{uncategorized},
   as it can suffer from a \textit{demoting} interference caused by the ninth
   instruction of Core2.
\end{itemize}
\end{example}
Thus, the effects of interference on instructions are fully exposed. However,
some uncertainties remain concerning the relation between each generated
interference. For example, can the first instruction of both core generate
interference in the same execution? This particular case can be easily
intuited, but using model checking to ensure that any such relation is made
known to the user is seemingly beyond UPPAAL's capabilities. Indeed, this would
require the ability to write a formula checking that, for any given
occurrences of interference, all can be found within the same execution. Since
the detection of an interference requires a temporal formula, this would be
a temporal formula containing a conjunction of temporal formula, which UPPAAL's
query language does not support.
