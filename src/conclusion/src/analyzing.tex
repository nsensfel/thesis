\section{Exposing the Interference}
By making a model that matches the applicant's architecture through profiling
benchmarks, model checking can be used to expose the interference generated by
cache coherence.

\subsection{Summary}
Chapter~\ref{cha:exposing_interference} proposes analyses to reveal how
programs are affected by cache coherence interference, and what generates it.
These analyses start by a simple computation of the execution time for each
program. In order to determine how much of this execution time is caused by
cache coherence, an alternative of each program is created, in which no shared
variable exists. This alternative does not have to correspond to anything that
would realistically run on the actual architecture. Indeed, the point is to
obtain the execution time of each of these alternative program and compare it
to the original: the difference indicates how much of this program's execution
time can be attributed to cache coherence.

The chapter proceeds by seeking information on the determining factor of
execution time: the accuracy of instructions performing memory accesses. To do
so, it uses model checking to categorize each instruction as being either
\textit{always-hit} (the data it uses sure to be available in the cache),
\textit{always-miss} (the data it uses sure to not be available in the cache),
and \textit{uncategorized} (there are executions in which the data is
available, others where it isn't). This, in effect, points out which
instructions cannot be hoped to perform faster, which should be the focus on
improvement, and which cause execution time variations. An auxiliary analysis
is also proposed, providing similar observations with a focus on the accuracy of
memory elements instead.

To determine how cache coherence affected the accuracy of instructions, the
chapter follows up by proposing categories defining the effects of external
queries on the permissions held by a cache. Three categories are proposed:
minor interference (no change of permissions, only incurrence of query
processing times), demoting interference (loss of writing permissions, but
reading permissions are kept), and expelling interference (all permissions are
lost). The chapter points out where each category of interference occurs on
the MSI, MESI, and MESIF protocols. It also indicates what should be considered
to be an occurrence of interference that has an impact on execution time.

By tracing the source of the external query back to its originating
instruction, it becomes possible to use model checking in order to determine
the effects of each instruction on the other instructions. In effect, this last
analyze provides the user with an understanding of, for each instruction, which
instructions can cause an interference, the category (and thus, effects) of
this interference, as well as if this interference occurs on every possible
execution or just some of them.

\subsection{Limitations}
This thesis proposes the use of model checking to expose interference. The
undeniable limitation of this approach is scalability. Indeed, the proposed
analyses have only been performed on toy examples. Realistic programs are
likely to be at least a hundredfold larger, and so is the number of cache lines
in each cache. The number of possible executions would then result in
exponentially more time and memory consumption for each analysis.

Another barrier to real-world use of the approach is the lack of automation.
Indeed, these analyses require a large number of queries to be performed
manually by the user. While the execution time analysis can reasonably be
undertaken on large models, the categorization of each instruction takes between
one and two query per instruction. Worse, obtaining the interference incurred by
each instruction can take up to $n^m$ queries, with $n$ being the size of
programs, and $m$ the number of caches.

The available model and model checking formula do not provide the means to
expose occurrences of minor interference that had an impact on execution time.

The results provide information about interference that happens on every
possible execution. It also provides information on interference that happens
in at least some executions. However, there is no established strategy to expose
the relations between occurrences of interference that are not present on every
execution. For example, the proposed formula do not provide any means to check
if a set of three arbitrarily chosen occurrences of interference can all happen
in the same execution.

\subsection{Future Works}
Creating tools to make all these analyses automatically should be the next step
in user-friendliness. Indeed, UPPAAL can be invoked from the command line, and
all the involved files are text-based, making it possible to parse and create
the appropriate results and model checking queries.

Support for exposing occurrences of minor interference that have an impact on
execution time might be feasible. However, considering the limited effects of
minor interference on a singular instruction, this information is likely
superfluous to the user.

On the other hand, being able to indicate the relations between the occurrences
of interference that do not happen on all executions would provide useful
information. The model is technically providing all the necessary variables to
write formulas that would indicate such relations. However, these formula would
require temporal operators that can be employed on temporal formula, instead of
the restricted variant of computation tree logic supported by UPPAAL.
